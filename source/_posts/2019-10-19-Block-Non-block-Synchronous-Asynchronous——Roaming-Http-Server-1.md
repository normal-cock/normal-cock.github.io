---
title: '阻塞\非阻塞与同步\异步——Http Server漫游(1)'
date: 2019-10-19 20:22:33
categories: Http Server漫游
tags: 
     - epoll
     - aio
     - non-blocking
     - asynchronous
---
关于“阻塞、非阻塞、同步、异步”的区别，网上众说纷纭，其中很大一部分人喜欢用一个生活中的比喻来解释。但我认为，比喻虽然生动形象，但是毕竟与计算机技术的实际场景有所不同，导致很多人在阅读的过程中看懂了例子，却还是弄不明白“阻塞、非阻塞、同步、异步”。因此本文中我将不在使用比喻，而是列举“阻塞、非阻塞、同步、异步”相关的例子来解释说明。

<!-- more -->
## 1. 写在开头

最近在爬长城（GFW）的时候，顺带研究了一下用到的一些网络组件的代码，将很久不用的网络知识重新梳理了一遍，收益良多。突然想起马云之前说的一句话：他们搞双十一不是为了赚钱，而是为了磨炼团队的技术实力。我想，大大们建长城的目的大概也是如此。想到这里，不禁一股暖意涌上心头。
于是，想到了写这个专题——Http Server漫游。

## 2. 为什么写这个专题呢？

一方面想借着这个机会将这段时间的学习成果沉淀下来，另一方面也想通过分享，查缺补漏。
当然，如果恰巧你阅读了部分内容，又恰巧这些内容帮助到你，那兄弟我深感荣幸。另外，由于水平有限，如果出现不正确的地方还请不吝赐教。

## 3. 这个专题会包含哪些内容呢？

主要是一些跟Http Server相关的一些知识，大到网络通讯的原理、网络模型、协程等，小到某个开源服务器的实现都会涉及。

## 4. 正篇

作为这个专题的第一篇，我想说说之前一直困扰我很久的一个问题“阻塞、非阻塞、同步、异步”。

关于“阻塞、非阻塞、同步、异步”的区别，网上众说纷纭，其中很大一部分人喜欢用一个生活中的比喻来解释。但我认为，比喻虽然生动形象，但是毕竟与计算机技术的实际场景有所不同，导致很多人在阅读的过程中看懂了例子，却还是弄不明白“阻塞、非阻塞、同步、异步”。因此本文中我将不在使用比喻，而是列举“阻塞、非阻塞、同步、异步”相关的例子来解释说明。

### 4.1. 字面意思解释

好，要开始了，接下来的内容请仔细阅读。
首先，我们先来看看这四个词语本身的含义。先来看一张表：

|词语|描述的主语|含义|
|:-|:-|:-|
|阻塞|调用者的状态|代表调用者会被卡住，不会继续向下执行|
|非阻塞|调用者的状态|代表调用者不会被卡主，会继续向下执行|
|同步|两者主体之间的合作模式|两者之间串行工作|
|异步|两者主体之间的合作模式|两者之间并行工作|

从这张表我们可以看出，阻塞与非阻塞描述的主语是一样的，同步和异步描述的主语是一样的。所以，可以得出第一个结论，**本质上“阻塞和非阻塞”与“同步和异步”之间并没有必然的关系**。

### 4.2. 对应的编程技术

接下来，我们来聊聊“阻塞、非阻塞、同步、异步”在我们的计算机编程中所代表的东西。
先说结论：
* 结论1：阻塞和非阻塞代表是否为打开的文件描述符设置了`O_NONBLOCK属性`。
* 结论2：同步和异步是指在对文件描述符进行IO操作时，是否使用了`epoll`等多路复用技术或者`AIO`。

如果不清楚我在说什么，建议看看网络编程相关的知识。如果看懂了之前描述“阻塞、非阻塞、同步、异步”的那张表格，也知道`O_NONBLOCK属性`, `多路复用`, `AIO`，但还是对我说的两条结论不太理解的话，也别着急，听我解释。

#### 4.2.1. 结论1

先说说**结论1**。
首先我们知道阻塞和非阻塞的主语是调用者，而文件描述符的调用者或者说操作者是打开和操作文件描述符的程序，因此此处`O_NONBLOCK`描述的便是操作文件描述符的程序的状态。

举个栗子，假设发生了如下事件：

1. `程序A`打开了网络`连接C`，默认情况下`C`的描述符的属性为阻塞模式，此处使用默认的阻塞模式
2. `程序A`试图在没有数据到来的情况下从`C`中读取数据。
3. 有数据到达`C`。

在默认阻塞模式下，第2步时`程序A`便会卡住，直到读到数据或者读取超时。而如果我们为`C`的文件描述符设置了`O_NONBLOCK`模式，则第2步时，`程序A`不会被卡住，而是通过`read`的返回值被告知当前没有可以读取的数据。`程序A`拿到了这个告知后便可以选择是继续等待，还是去执行其他的任务了，而不会被一直卡住。
这就是“阻塞和非阻塞”在编程时对应的东西。

#### 4.2.2. 结论2

接下来我们说说**结论2**。
还是先说说这两个词本身，“同步和异步”这两个词所描述的是两个主体之间的合作模式，而针对文件描述符的操作来说，这两个主体便是指操作文件描述符的程序和文件描述符所代表的资源管理者。
接着用上面的例子，“同步和异步”所描述便是两个主体——`程序A`和`连接C`——之间的合作模式。在同步模式下，`程序A`的行为和`连接C`的行为是串行进行的，即在步骤2时，`程序A`调用`read`接口去读取数，此时控制权交给了`连接C`，`连接C`根据是否有数据以及是否使用了`O_NONBLOCK`来决定什么时候将控制权交给`程序A`。无论何种情况，只要`C`不将控制权交给`A`，`A`便无法处理其他事情，所以说两者是串行执行的。
而如果使用了epoll或AIO，则两者的合作模式将会发生改变，即`程序A`只有在收到`连接C`的通知时，才会去读取或写入`C`，而在没有通知时，`程序A`可以去处理其他的事情或其他消息，因此两者之间是并行的。

#### 4.2.3. 非阻塞与异步的“特殊”关系

但是有一点要注意，虽说“阻塞和非阻塞”与“同步和异步”之间并没有必然的关系，但在使用时，部分的异步处理方式需要使用非阻塞模式来支撑。具体关系为：
* **使用`epoll`时，分两种情况**（如果不了解，请参考unix网络编程）.
    1. **边缘触发时，必须使用非阻塞IO**。由于此时每次新数据到来只会触发一次epoll事件，无论新数据有没有读取都是这样。因此需要不停地read读取所有数据，如果使用阻塞模式，肯达概率会在最后一次读取时由于无数据可读而卡住。
    2. **水平触发时，阻塞和非阻塞IO都可以**。该模式下，主要有可以读取的数据，便会触发epoll事件，而不管数据是新到来的还是上一次未读完的。因此一般在有epoll事件触发时才会去读取，所以不会阻塞，因为肯定能读到数据。另外，即使read指定读取的数据量大于实际收到的数据量，也不会阻塞，而是在read操作结束时返回实际read的数据量大小。所以要注意的是，一次触发epoll事件只能对应一个read或write操作，如果一次触发进行了多次read或write，则会有阻塞的风险。
* **使用`aio`时，阻塞和非阻塞IO都可以。**

### 4.3. epoll和AIO的区别

最后，在简单说一下epoll和AIO的区别：
* **通知的含义不同**。epoll 是在连接打开、关闭、可读、可写的时候，收到通知；AIO 是在读写（通过 aio_read 或 aio_write 发起）完成之后（将要读的内容读到 application 指定的位置或将 application 指定的位置的内容写入成功）的通知。
* **响应通知的 execution context 不同**。epoll 是在调用线程中执行；而 aio 可以以 signal 、new thread 的方式来响应通知。
* **适用场景有所差异**。epoll 主要用于网络和管道，不能操作文件；而 aio 几乎都可以。

## 5. 参考资料

<http://www.man7.org/linux/man-pages/man7/socket.7.html>
<http://www.man7.org/linux/man-pages/man7/epoll.7.html>
<https://stackoverflow.com/questions/8057892/epoll-on-regular-files>
